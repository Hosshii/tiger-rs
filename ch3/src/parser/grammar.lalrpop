use crate::{lexer::{Error as LexError, TokenKind, Reserved, Separator, StringLiteral, Ident}, parser::ast};

grammar;

pub Program: ast::Program = {
    <Expr> => ast::Program::Expr(<>),
    <Decls> => ast::Program::Decls(<>),
}

Expr: ast::Expr = {
    MatchedIf => <>,
    UnmatchedIf => <>,
}

MatchedIf: ast::Expr = {
    "if" <e1:Expr> "then" <e2:MatchedIf> "else" <e3:MatchedIf> => ast::Expr::IfThenElse(Box::new(e1), Box::new(e2), Box::new(e3)),
    ExprType1 => <>,
}

UnmatchedIf: ast::Expr = {
    "if" <e1:Expr> "then" <e2:Expr> => ast::Expr::IfThen(Box::new(e1), Box::new(e2)),
    "if" <e1:Expr> "then" <e2:MatchedIf> "else" <e3:UnmatchedIf> => ast::Expr::IfThenElse(Box::new(e1), Box::new(e2), Box::new(e3)),
}

ExprType1: ast::Expr = {
    // <id:TypeIdent> "[" <e1:Expr> "]" "of" <e2:MatchedIf> => {
    <id:Ident> "[" <e1:Expr> "]" "of" <e2:MatchedIf> => {
        ast::Expr::ArrayCreation {
            type_id: ast::TypeIdent(id),
            size: Box::new(e1),
            init: Box::new(e2)
        }
    },
    <type_id:TypeIdent> "{" <f1:(Ident "=" Expr ("," Ident "=" MatchedIf)*)?>  "}" => {
        let fields = if let Some((id, _, expr, _fields)) = f1 {
            let fields = vec![ast::RecordField {id: id, expr: expr}];
            let iter = _fields.into_iter().map(|(_, id, _, expr)| ast::RecordField {id: id, expr: expr});
            fields.into_iter().chain(iter).collect()
        }else {
            ast::RecordFields::new()
        };

        ast::Expr::RecordCreation(type_id, fields)
    },

    <Or> => <>,

    <l:LValue> ":=" <e:MatchedIf> => ast::Expr::Assign(l, Box::new(e)),

    "while" <e1:Expr> "do" <e2:MatchedIf> => ast::Expr::While(Box::new(e1), Box::new(e2)),
    "for" <id:Ident> ":=" <e1:Expr> "to" <e2:Expr> "do" <e3:MatchedIf> => {
        ast::Expr::For(id, Box::new(e1), Box::new(e2), Box::new(e3))
    },
}

LValue: ast::LValue = {
    <Ident> => ast::LValue::Var(<>),
    LValueNotID => <>,
}

LValueNotID: ast::LValue = {
    <l:LValue> "." <i:Ident> => ast::LValue::RecordField(Box::new(l), i),
    <l:Ident> "[" <e:Expr> "]" => ast::LValue::Array(Box::new(ast::LValue::Var(l)), Box::new(e)),
    <l:LValueNotID> "[" <e:Expr> "]" => ast::LValue::Array(Box::new(l), Box::new(e)),
}

ExprSeq = Semicolon<Expr>;

BracketedExprs: ast::Expr = {
    "(" <ExprSeq> ")" => ast::Expr::Sequence(<>),
}

Decls: Vec<ast::Decl> = {
    <d:Decl*> => <>
}

Decl: ast::Decl = {
    TypeDecl => ast::Decl::Type(<>),
    VarDecl => ast::Decl::Var(<>),
    FuncDecl => ast::Decl::Func(<>),
} 

TypeDecl: ast::TypeDecl = {
    "type" <id:TypeIdent> "=" <ty:Type> => {
        ast::TypeDecl {
            id: id,
            ty: ty,
        }
    }
}

Type: ast::Type = {
    TypeIdent => ast::Type::Id(<>),
    "{" <TypeFields> "}" => ast::Type::Fields(<>),
    "array" "of" <TypeIdent> => ast::Type::Array(<>),
}

TypeFields: ast::TypeFields = {
    <f: NonZeroTypeFields?> => {
        if let Some(fields) = f {
            fields
        }else {
            Vec::new()
        }
    }
}

NonZeroTypeFields: ast::TypeFields = {
    <i1:Ident> ":" <i2:TypeIdent> <f2:("," Ident ":" TypeIdent)*> => {
        let mut fields = Vec::new();
        fields.push(ast::TypeField {id: i1, type_id: i2});
        for (id, type_id) in f2.into_iter().map(|v| (v.1, v.3)) {
            fields.push(ast::TypeField {id: id, type_id: type_id});
        }
        fields
    }
}

VarDecl: ast::VarDecl = {
    "var" <Ident> ":=" <Expr> => {
        ast::VarDecl::Short(<>)
    },
    "var" <Ident> ":" <TypeIdent> ":=" <Expr> => {
        ast::VarDecl::Long(<>)
    } 
}

TypeIdent: ast::TypeIdent = {
    <Ident> => ast::TypeIdent(<>),
}

FuncDecl: ast::FuncDecl = {
    "function" <Ident> "(" <TypeFields> ")" "=" <Expr> => {
        ast::FuncDecl::Short(<>)
    },
    "function" <Ident> "(" <TypeFields> ")" ":" <TypeIdent> "=" <Expr> => {
        ast::FuncDecl::Long(<>)
    }
}

// precedence 
// strong --> weak
//  Mul --> Add --> Comp --> And --> Or --> ExperType1

Or = Tier<OrOp, And>;
And = Tier<AndOp, Comp>;
Comp = Tier<CompOp, Add>;
Add = Tier<AddOp, Mul>;
Mul = Tier<MulOp, Neg>;
Neg: ast::Expr = {
    "-" <Neg> => ast::Expr::Neg(Box::new(<>)),
    Primary => <>,
}

Primary: ast::Expr = {
    "nil" => ast::Expr::Nil,
    <Int> => ast::Expr::Int(<>),
    <Str> => ast::Expr::Str(<>),
    BracketedExprs => <>,
    "break" => ast::Expr::Break,
    "let" <Decls> "in" <ExprSeq> "end" => ast::Expr::Let(<>),
    <LValueNotID> => ast::Expr::LValue(<>),
    <Ident> => ast::Expr::LValue(ast::LValue::Var(<>)),
    <Ident> "(" <Comma<Expr>> ")" => ast::Expr::FuncCall(<>),
}

MulOp: ast::Operator = {
    "*" => ast::Operator::Mul,
    "/" => ast::Operator::Div,
}

AddOp: ast::Operator = {
    "+" => ast::Operator::Plus,
    "-" => ast::Operator::Minus,
}

CompOp: ast::Operator = {
    "=" => ast::Operator::Eq,
    "<>" => ast::Operator::Neq,
    ">=" => ast::Operator::Ge,
    ">" => ast::Operator::Gt,
    "<=" => ast::Operator::Le,
    "<" => ast::Operator::Lt,
}

AndOp: ast::Operator = {
    "&" => ast::Operator::And,
}

OrOp: ast::Operator = {
    "|" => ast::Operator::Or,
}

Semicolon<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Tier<Op,NextTier>: ast::Expr = {
    <lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> => ast::Expr::Op(op, Box::new(lhs), Box::new(rhs)),
    NextTier
};

extern {
    type Location = usize;
    type Error = LexError;

    enum TokenKind {
        "type" => TokenKind::Reserved(Reserved::Type),
        "var" => TokenKind::Reserved(Reserved::Var),
        "function" => TokenKind::Reserved(Reserved::Function),
        "break" => TokenKind::Reserved(Reserved::Break),
        "of" => TokenKind::Reserved(Reserved::Of),
        "end" => TokenKind::Reserved(Reserved::End),
        "in" => TokenKind::Reserved(Reserved::In),
        "nil" => TokenKind::Reserved(Reserved::Nil),
        "let" => TokenKind::Reserved(Reserved::Let),
        "do" => TokenKind::Reserved(Reserved::Do),
        "to" => TokenKind::Reserved(Reserved::To),
        "for" => TokenKind::Reserved(Reserved::For),
        "while" => TokenKind::Reserved(Reserved::While),
        "else" => TokenKind::Reserved(Reserved::Else),
        "then" => TokenKind::Reserved(Reserved::Then),
        "if" => TokenKind::Reserved(Reserved::If),
        "array" => TokenKind::Reserved(Reserved::Array),

        ":=" => TokenKind::Separator(Separator::ColonEqual),
        "|" => TokenKind::Separator(Separator::Pipe),
        "&" => TokenKind::Separator(Separator::Ampersand),
        ">=" => TokenKind::Separator(Separator::GreaterOrEqual),
        ">" => TokenKind::Separator(Separator::Greater),
        "<=" => TokenKind::Separator(Separator::LesserOrEqual),
        "<" => TokenKind::Separator(Separator::Lesser),
        "<>" => TokenKind::Separator(Separator::NotEqual),
        "=" => TokenKind::Separator(Separator::Equal),
        "/" => TokenKind::Separator(Separator::Slash),
        "*" => TokenKind::Separator(Separator::Star),
        "-" => TokenKind::Separator(Separator::Hyphen),
        "+" => TokenKind::Separator(Separator::Plus),
        "." => TokenKind::Separator(Separator::Dot),
        "{" => TokenKind::Separator(Separator::LBrace),
        "}" => TokenKind::Separator(Separator::RBrace),
        "[" => TokenKind::Separator(Separator::LBrack),
        "]" => TokenKind::Separator(Separator::RBrack),
        "(" => TokenKind::Separator(Separator::LParen),
        ")" => TokenKind::Separator(Separator::RParen),
        ";" => TokenKind::Separator(Separator::Semicolon),
        ":" => TokenKind::Separator(Separator::Colon),
        "," => TokenKind::Separator(Separator::Comma),

        Str => TokenKind::Str(<StringLiteral>),

        Int => TokenKind::Int(<u64>),

        Ident => TokenKind::Ident(<Ident>),

        Eof => TokenKind::Eof,
    }
}
